import { ChannelWrapper, AmqpConnectionManager } from 'amqp-connection-manager';
import { ConsumeMessage, Channel, Connection, ConfirmChannel, Options } from 'amqplib';
import { MessageHandlerOptions, RabbitMQConfig, RequestOptions, ConsumeOptions } from '../rabbitmq.interfaces';
import { RpcResponse, SubscribeResponse } from './handlerResponses';
export type ConsumerTag = string;
export type SubscriberHandler<T = unknown> = (msg: T | undefined, rawMessage?: ConsumeMessage, headers?: any) => Promise<SubscribeResponse>;
export type BatchSubscriberHandler<T = unknown> = (msg: (T | undefined)[], rawMessage?: ConsumeMessage[], headers?: any[]) => Promise<SubscribeResponse>;
export type RpcSubscriberHandler<T = unknown, U = unknown> = (msg: T | undefined, rawMessage?: ConsumeMessage, headers?: any) => Promise<RpcResponse<U>>;
export interface CorrelationMessage {
    correlationId: string;
    requestId?: string;
    message: Record<string, unknown>;
}
export interface SubscriptionResult {
    consumerTag: ConsumerTag;
}
export type BaseConsumerHandler = {
    consumerTag: string;
    channel: ConfirmChannel;
    msgOptions: MessageHandlerOptions;
};
export type ConsumerHandler<T, U> = (BaseConsumerHandler & {
    type: 'subscribe';
    handler: SubscriberHandler<T>;
}) | (BaseConsumerHandler & {
    type: 'subscribe-batch';
    handler: BatchSubscriberHandler<T>;
}) | (BaseConsumerHandler & {
    type: 'rpc';
    handler: RpcSubscriberHandler<T, U>;
});
export declare class AmqpConnection {
    private readonly messageSubject;
    private readonly logger;
    private readonly initialized;
    private _managedConnection;
    /**
     * Will now specify the default managed channel.
     */
    private _managedChannel;
    private _managedChannels;
    /**
     * Will now specify the default channel.
     */
    private _channel;
    private _channels;
    private _connection?;
    private _consumers;
    private readonly config;
    private readonly outstandingMessageProcessing;
    constructor(config: RabbitMQConfig);
    get channel(): Channel;
    get connection(): Connection;
    get managedChannel(): ChannelWrapper;
    get managedConnection(): AmqpConnectionManager;
    get configuration(): Required<RabbitMQConfig>;
    get channels(): Record<string, ConfirmChannel>;
    get managedChannels(): Record<string, import("amqp-connection-manager/dist/types/ChannelWrapper").default>;
    get connected(): boolean;
    init(): Promise<void>;
    private initCore;
    private setupInitChannel;
    private setupQueuesWithBindings;
    private initDirectReplyQueue;
    request<T>(requestOptions: RequestOptions): Promise<T>;
    createSubscriber<T>(handler: SubscriberHandler<T>, msgOptions: MessageHandlerOptions, originalHandlerName: string, consumeOptions?: ConsumeOptions): Promise<SubscriptionResult>;
    createBatchSubscriber<T>(handler: BatchSubscriberHandler<T>, msgOptions: MessageHandlerOptions, consumeOptions?: ConsumeOptions): Promise<SubscriptionResult>;
    private consumerFactory;
    /**
     * Wrap a consumer with logic that tracks the outstanding message processing to
     * be able to wait for them on shutdown.
     */
    private wrapConsumer;
    private setupSubscriberChannel;
    private setupBatchSubscriberChannel;
    private handleBatchedMessages;
    createRpc<T, U>(handler: RpcSubscriberHandler<T, U>, rpcOptions: MessageHandlerOptions): Promise<SubscriptionResult>;
    setupRpcChannel<T, U>(handler: RpcSubscriberHandler<T, U>, rpcOptions: MessageHandlerOptions, channel: ConfirmChannel): Promise<ConsumerTag>;
    publish(exchange: string, routingKey: string, message: any, options?: Options.Publish): Promise<boolean>;
    private deserializeMessage;
    private setupQueue;
    private setupManagedChannel;
    /**
     * Selects managed channel based on name, if not found uses default.
     * @param name name of the channel
     * @returns channel wrapper
     */
    private selectManagedChannel;
    private registerConsumerForQueue;
    private unregisterConsumerForQueue;
    private getConsumer;
    get consumerTags(): string[];
    cancelConsumer(consumerTag: ConsumerTag): Promise<void>;
    resumeConsumer<T, U>(consumerTag: ConsumerTag): Promise<ConsumerTag | null>;
    close(): Promise<void>;
}
//# sourceMappingURL=connection.d.ts.map